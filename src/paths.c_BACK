/*
** paths.c for my_ls in /home/boitea_r
** 
** Made by Ronan Boiteau
** Login   <boitea_r@epitech.net>
** 
** Started on  Wed Nov 25 21:15:48 2015 Ronan Boiteau
** Last update Sun Nov 29 20:19:12 2015 Ronan Boiteau
*/

#include "my.h"
#include "my_macro.h"
#include "ls_system.h"
#include "ls_args.h"
#include "ls_data.h"

static int		_isdir(char *dir)
{
  int			idx;

  idx = 0;
  while (dir[idx])
    {
      if (dir[idx] == '/')
	return (TRUE);
      idx += 1;
    }
  return (FALSE);
}

static void		_arg_isfile(char *dir, t_data *data)
{
  DIR			*dir_ptr;
  struct dirent		*entry;
  int			found;

  data->filename = my_strdup(dir);
  data->full_path = _isdir(dir);
  data->dir = dir;
  if (data->full_path == TRUE)
    {
      data->idx = my_strlen(dir) - 1;
      while (data->dir[data->idx] && data->dir[data->idx] != '/')
	{
	  data->dir[data->idx] = '\0';
	  data->idx -= 1;
	}
      data->idx = my_strlen(data->dir);
      while (data->filename[data->idx] && data->filename[data->idx] != '/')
	data->idx -= 1;
      data->filename += data->idx + 1;
      if ((dir_ptr = opendir(data->dir)) == NULL)
      	{
      	  if (data->only_errors == TRUE)
      	    my_put_error("ssss", "ls: cannot access ", data->dir,
			 data->filename, ": No such file or directory\n");
      	  return ;
      	}
    }
  else
    data->dir = my_strdup(".");
  dir_ptr = opendir(data->dir);
  found = FALSE;
  while ((entry = readdir(dir_ptr)) != NULL)
    {
      if (match(data->filename, entry->d_name))
  	{
  	  if (data->only_errors == FALSE)
  	    {
  	      if (data->full_path == TRUE)
  		my_putstr(data->dir);
  	      my_putstr(entry->d_name);
  	      my_putchar('\n');
  	      data->extra_eol = TRUE;
  	    }
  	  found = TRUE;
  	}
    }
  if (found == FALSE && data->only_errors == TRUE)
    {
      if (data->full_path == TRUE)
  	my_put_error("ssss", "ls: cannot access ", data->dir, data->filename,
		     ": No such file or directory\n");
      else
	my_put_error("sss", "ls: cannot access ", data->filename,
		     ": No such file or directory\n");
    }
  return ;
}

int			_count_valid_paths(t_args *args, int errors)
{
  int			idx;
  int			paths;

  paths = 0;
  idx = 1;
  while (idx < args->argc)
    {
      if (args->argv[idx][0] != '-')
	paths += 1;
      idx += 1;
    }
  return (paths - errors);
}

int			_check_args(t_args *args,
				    int only_errors,
				    int *extra_eol)
{
  DIR			*dir_ptr;
  char			*dir;
  t_data		*data;
  int			errors;

  data = malloc(sizeof(data));
  data->only_errors = only_errors;
  data->extra_eol = *extra_eol;
  errors = 0;
  args->idx = 1;
  while (args->idx < args->argc)
    {
      if (args->argv[args->idx][0] != '-')
	{
	  dir = my_strdup(args->argv[args->idx]);
	  if ((dir_ptr = opendir(dir)) == NULL)
	    {
	      _arg_isfile(dir, data);
	      errors += 1;
	    }
	  free(dir);
	  closedir(dir_ptr);
	}
      args->idx += 1;
    }
  free(data);
  return (errors);
}
